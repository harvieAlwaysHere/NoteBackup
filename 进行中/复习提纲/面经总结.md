[TOC]



# 算法与数据结构

##### HashMap相关

* 内部数据结构，数组+链表<=>红黑树

  * 链表长度 > 8 & 数组大小  >= 64，链表转换成红黑树
  * 红黑树节点个数 < 6，红黑树转换成链表

* 数据插入原理

  * 数组是否为空，为空则初始化
  * 计算插入key的hash值和存放数组的索引位置
  * 数组无节点，构造节点存储数据
  * 数组有节点，哈希冲突，遍历链表/红黑树，判断key是否相等
    * 相等则替换value
    * 不相等，则创建节点插入链表/红黑树
  * 插入完成判断当前节点数是否大于阈值，大于则扩容

* HashMap初始容量，默认16，若指定大小k，则初始化为大于k的2的整数次方

* 哈希函数设计原则

  * 降低hash碰撞，均匀映射到哈希空间
  * 简单高效

* HashMap的哈希函数实现(扰动函数)

  * key的hashcode(32位)的高16位与低16位进行异或运算

    * 降低hash碰撞，涉及到计算数组索引时需要取模数组大小

      * 哈希值与数组值采用 hash & (n-1)，由于数组大小是2的次方，因此 n-1 相当于是一个低位掩码，仅保留hash值的低位
      * hash值低位可能冲突较大，通过高位与低位异或，即保留了高位的部分特征，也加大了低位的随机性

      ![img](https://img-blog.csdnimg.cn/2021011222370058.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NRWTA4MDk=,size_16,color_FFFFFF,t_70)

    * 简单高效，位运算

  ```java
  static final int hash(Object key) {
      int h;
      return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
  }
  ```

* HashMap JDK 1.8 优化和原因

  * 数组+链表 => 数组+链表+红黑树

    * 防止hash冲突导致链表长度过长，将时间复杂度由O(n)降为O(logn)

  * 头插法 => 尾插法

    * 头插法扩容时会发生链表反转，此时若另一个线程也在插入节点，会造成循环链表(环)

  * 扩容重新计算hash定位元素位置 => 位置不变 或 索引+旧容量大小

    * 扩容数组容量变两倍，相当于低位掩码多了一位1，直接获取节点的原hash，计算hash值在低位掩码新的1的那位的值，若为0则索引不变，若为1则索引增大旧数组容量

      ![img](https://img-blog.csdnimg.cn/2019021916223252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdlMTk5MQ==,size_16,color_FFFFFF,t_70)

* HashMap线程安全问题和解决方案

  * 死循环(1.7)，数据丢失(1.7)，数据覆盖(1.7 + 1.8)，同时扩容
  * HashTable，Collections.synchronizedMap，ConcurrentHashMap
    * ConcurrentHashMap成员变量采用volatile修饰避免指令重排序和内存可见性，CAS+synchronized保证线程操作只会锁住当前操作的索引节点

##### 哈夫曼树

构建n个带权值的节点的树，使得这棵树的带权路径长度最小(权值*节点深度)，称为最优二叉树，即哈夫曼树，构建过程如下

1. 在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和
2. 在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推
3. 重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树

特点

* 哈夫曼编码
  * 频率高(权重大)的节点编码短，反之编码长
  * 编码(解码)保证唯一，即短编码与长编码的左起子串不冲突
* 同权不同构造，夫曼树的构造并不是唯一的















# 计算机网络

##### TCP四次挥手为什么要2msl等待时间？

msl，即Maximum Segment Lifetime，报文在网络上存在的最长时间，超时报文将被丢弃

* 保证A发送的最后一个ACK报文能到达B，若丢失B超时重传上一个报文，A等待2msl也会重传最后一个ACK报文
* 保证连接所产生的所有报文段从网络消失，新连接不会出现旧连接请求的报文段

##### DNS的IP查找

域名结构分为，根域名，顶级域名，二级及多级域名

* 本地查询，浏览器缓存和系统Host文件缓存
* 网关查询，路由器缓存和ISP(运营商)缓存
* 本地DNS服务器缓存查询
* 根域名服务器 -> 顶级域名服务器 -> 二级域名服务器的迭代查询

HTTP 与 HTTPS 有哪些区别？

TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？

简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？

简述什么是 XSS 攻击以及 CSRF 攻击？

简述 TCP 中的拥塞控制与滑动窗口机制

简述 HTTP 1.0，1.1，2.0 的主要区别

SSL握手流程为什么要使用对称秘钥？

从输入 URL 到展现页面的全过程

简述 JWT 的原理和校验机制

DNS 查询服务器的基本流程是什么？DNS 劫持是什么？

TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？







# 操作系统

##### 进程间有哪些通信方式(IPC)？

* 管道，半双工(数据单向流动)，父子进程间运用
* 命名管道FIFO，半双工，可用于任意进程
* 信号(Signal)，通知进程某个事件发生，如子进程通知父进程
* 信号量，锁机制，控制多个进程对共享资源的访问
* 消息队列，存放在内核的消息链表
* 共享内存，映射一段能被多个进程访问的内存，效率高
* 套接字(Socket)，可支持跨网络进程间的通信机制

进程和线程之间有什么区别？

进程通信中的管道实现原理是什么？

简单介绍进程调度的算法

Linux 下如何排查 CPU 以及 内存占用过多？

简述 Linux 虚拟内存的页面置换算法

I/O多路复用中 select, poll, epoll之间有什么区别，各自支持的最大描述符上限以及原因是什么？

LVS 的 NAT、TUN、DR 原理及区别

系统调用的过程是怎样的？操作系统是通过什么机制触发系统调用的？





# 数据库

##### 实战题

如下数据库表

* 会员信息表(member)

  会员ID(uid)，年龄(age)，组织ID(org_id)

* 审批流程表(workflow)

  流程ID(id)，会员ID(uid)，流程创建时间(gmt_create)，流程结束时间(gmt_finish) 

请写出以下需求的SQL代码

1. 使用过审批流程的用户在各年龄段上的人数分布，年龄段包含未成年(0-17)、青年(18-40)、中年(41-65)、老年(大于65)

   ```mysql
   # UNION ALL 方式
   SELECT "未成年(0-17)" AS "年龄分布", COUNT(m.uid) AS "数量"
   FROM member AS m
   LEFT JOIN workflow AS w ON (m.uid = wf.uid)
   WHERE m.age >= 0 AND m.age <= 17
   AND w.id IS NOT NULL
   GROUP BY m.uid
   
   UNION ALL 
   
   SELECT "青年(18-40)" AS "年龄分布", COUNT(m.uid) AS "数量"
   FROM member AS m
   LEFT JOIN workflow AS w ON (m.uid = wf.uid)
   WHERE m.age >= 18 AND m.age <= 40
   AND w.id IS NOT NULL
   GROUP BY m.uid
   ...
   
   # CASE WHEN方式
   SELECT ageGap AS '年龄段', COUNT(*) AS '人数' 
   FROM 
       (SELECT 
           CASE 
           WHEN m.age >= 0 AND m.age <= 17 THEN '未成年(0-17)'
           WHEN m.age >= 18 AND m.age <= 40 THEN '青年(18-40)'
           WHEN m.age >= 41 AND m.age <= 65 THEN '中年(41-65)'
           ELSE '老年(大于65)'
           END AS ageGap
       FROM member AS m
       LEFT JOIN workflow AS w ON (m.uid = wf.uid)
       WHERE w.id IS NOT NULL
       GROUP BY m.uid,m.age) AS ageView
   GROUP BY ageGap
   ```

2. 如果某个uid的审批流程非常多，超过1000万条，如何提升问题1中SQL的执行速度？ 

3. 计算“组织人均审批完成时长”指标，每个人只取最近10条已完成的流程

##### 数据库连接池实现原理

* JDBC直接操作数据库流程

  加载数据库驱动，建立数据库连接，访问数据库执行sql语句闭并处理执行结果，断开数据库连接

  网络层面是，TCP建立连接，MYSQL三次握手认证，执行SQL，MYSQL连接关闭，TCP连接关闭

  缺点，网络IO多，数据库负载高，响应时间长，临时连接对象多(GC频繁)

* 数据库连接池

  * 池化思想，为了最大化收益并最小化风险，而将资源统一在一起管理
  * 数据库连接池，预先申请数据库连接，提升申请连接的速度，降低系统的开销
  * 流程
    * 建立数据库连接池对象，初始化连接【空闲连接数】
    * 对于数据库访问请求，从池中获取连接，若无空闲连接且连接数没有达到【最大连接数】，新建连接，达到最大连接数，将请求访问阻塞队列
    * 执行SQL，返回执行结果，关闭连接，将连接放回池中或释放连接
    * 服务停止，释放数据库连接池对象并释放所有连接
  * 相关实现，dbcp(jdbc)，c3p0，druid
  * Druid配置，DataSource(url/name/pwd)，initialSize/minIdle/maxActive，maxWait(获取连接的最大等待时间，配置后启用公平锁)

* MyBatis操作数据库流程

  * SqlSessionFactoryBuilder读取配置文件构造SqlSessionFactory
  * SqlSessionFactory打开数据库会话构造SqlSession
  * SqlSession的代理实现Executor调度三个组件查询数据库
    * StatementHandler，SQL语句执行器
    * ParameterHandler，SQL入参处理器，参数化查询preparedStatement
      * 预编译，提升查询效率
      * 参数化，动态查询
      * 防止SQL注入，会将用户输入的非法字符用\作转义
    * ResultSetHandler，结果映射器(ORM)，将查询结果映射到POJO中

  





简述乐观锁以及悲观锁的区别以及使用场景

数据库的事务隔离级别有哪些？各有哪些优缺点？

为什么 Redis 在单线程下能如此快？

MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？

Redis 有几种数据结构？Zset 是如何实现的？

MySQL 的索引什么情况下会失效？

MySQL 有哪些常见的存储引擎？它们的区别是什么？

什么情况下会发生死锁，如何解决死锁？

Redis 如何实现分布式锁？

简述主从复制以及读写分离的使用场景

数据库有哪些常见索引？数据库设计的范式是什么？

简述 SQL 中左连接和右连接的区别

数据库的读写分离的作用是什么？如何实现？

简述数据库中的 ACID 分别是什么？

什么是数据库事务，MySQL 为什么会使用 InnoDB 作为默认选项

Redis 中，sentinel 和 cluster 的区别和适用场景是什么？

简述 Redis 持久化中 rdb 以及 aof 方案的优缺点

Kafka 发送消息是如何保证可靠性的？









# Java

##### ThreadLocal



##### JVM调优

相关工具

* jps，列出正在运行的虚拟机进程
* jstat，监视虚拟机运行状态信息，如堆栈空间、GC次数时间原因等信息
* jmap，生成堆存储快照(dump)，如堆中对象(类/实例)信息、GC回收器类型参数
* jstack，生成虚拟机当前时刻的线程快照，可定位线程问题，如Monitor锁状态、线程状态、死锁等

相关参数

![](./JVM调优.png)

##### 垃圾回收的流程(CMS/G1)



##### Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？

* 引用计数法、可达性分析、方法区回收(卸载类)、finalize()重新引用自救
* 标记清除法、标记整理法、复制算法、分代收集法

##### 简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度

* 数组实现，get-O(1)，add末尾-O(1)，remove-O(N)，add指定位置-O(N)
* 双向链表，get-O(N)，add末尾-O(1)，remove-O(1)，add指定位置-O(N)

##### Java 类的加载流程是怎样的？什么是双亲委派机制？

* 加载，验证，准备，解析，初始化
* 一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载

##### HashMap 实现原理，为什么使用红黑树？

* 基于哈希桶的拉链法
* 红黑树较平衡，插入、删除等操作效率高，检索速度块

##### 实现单例设计模式（懒汉，饿汉）

```java
// 饿汉 直接实例化 线程安全 
public class Singleton{
    
    private static Singleton instance =  new Singleton();
    
    private Singleton(){}
    
    public static Singleton get(){
        return instance;
    }
    
}

// 懒汉 double-check 延迟加载节约资源
public class Singleton{
    
    // volatile 禁止初始化时重排序 避免线程获取未初始化的实例
    private volatile static Singleton instance;
    
    private Singleton(){}
    
    // double-check
    public static Singleton get(){
        if(instance == null){
            synchronized(Singleton.class){
                if(instance == null) instance = new Singleton();
            }
        }
        return instance;
    }
    
}

// 单例类懒汉+静态内部类饿汉 延迟加载 + JVM提供线程安全支持
public class Singleton{
    
    private Singleton(){}
    
    // JVM保证类加载的<clinit>()方法在多线程环境下能被正确加锁和同步
    private static class SingletonHolder{
        private static Singleton INSTANCE = new Singleton();
    }
    
    public static Singleton get(){
        return SingletonHolder.INSTANCE;
    }
}
```

##### HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？

* HashMap，线程不安全，拉链法
* ConcurrentHashMap，线程安全，JDK1.8前用默认16个基于ReentrantLock的分段锁Segment保证并发，JDK1.8后用CAS支持更高并发，CAS失败用内置锁synchronized

##### 常用的排序方式有哪些，时间复杂度是多少？

* 选择，冒泡，插入(取决初始顺序)，O(n^2)
* 快速，归并，堆O(nlogn)
* 希尔

##### 简述 Spring bean 的生命周期

* BeanDefinition

  扫描XML/注解(@Scope/@Lazy/@DependsOn)/JavaConfig封装成BeanDefinition放到Map中与BeanName对应，是Bean的元数据

* BeanFactoryPostProcess，占位符信息注入等

* 实例化，反射选择合适构造器实例化对象

* 属性赋值，设置对象属性

* 初始化

  * Aware接口相关填充
  * BeanPostProcessor.before()，AOP
  * init相关拓展方法，@PostConstruct->InitializingBean接口->init-method()
  * BeanPostProcessor.after()，AOP

* 销毁，destroy()

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/E44aHibktsKY4TrzFA3qC7iaIwcmI2y4hkdialmk34DqaTCkSqBiapLmolicenhffWWNpugytCPtfR99Biaq9OmuJN5g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

##### 如何解决依赖注入的循环依赖？

* 无法解决的循环依赖

  * 构造方法注入导致循环依赖，因为Spring依赖构造方法实例化Bean解决循环依赖
  * @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)注入

* 可以解决的循环依赖，Singleton模式的属性注入

* Spring解决循环依赖的方法

  核心思想是提前曝光，注入引用，三级缓存模式

  ![img](https://pic3.zhimg.com/v2-b305277c6e4b6bc1b4a817dc82a410ea_b.jpg)

##### JVM 中内存模型是怎样的，简述新生代与老年代的区别？

* 线程内存，如程序计数器，Java虚拟机栈，本地方法栈
* 虚拟机内存，如堆，方法区
* 直接内存，NIO分配堆外内存

##### 基于分代收集算法进行划分

* 新生代复制算法，老年代标记清除/整理法
* MinorGC和FullGC
* 新生代晋升老年代

##### == 和 equals() 的区别？

* ==
  * 基本数据类型，比较的是值，字面量概念
  * 引用类型，比较的是引用的堆内存地址(是否是同一个对象)
* equals
  * 引用类型，默认比较的也是堆内存地址，一般会被重写成比较值

##### 简述 Synchronized，Volatile，可重入锁的不同使用场景及优缺点

* Synchronized，JVM提供的隐式锁，用于同步代码块、方法、类等，可重入，不可中断，非公平，无死锁问题，使用方式简单，JVM优化
* Volatile，关键字，用于保证共享变量的可见性和有序性
* ReentrantLock(可重复锁)，JDK提供的显示锁，用于同步代码块，可重入，可中断，可公平/非公平，需手动释放(死锁)，提供丰富功能(定时锁等待、可中断锁等待、公平锁、Conditon通知/等待机制)

##### Java 中 sleep() 与 wait() 的区别

* sleep()是Thread类的静态方法，wait()是Object类的实例方法

* sleep()不会释放对象锁，wait()会释放锁
* sleep()结束后有CPU资源可立刻执行，wait()结束后还需要notify()唤醒
* wait()要在同步代码块中使用

##### volatile 关键字解决了什么问题，它的实现原理是什么？

* volatile修饰的变量在多线程中可保证可见性和有序性

  * 保证可见性原理

    缓存一致性协议，更新和读取共享变量会冲刷处理器缓存

  * 保证有序性原理

    线程对volatile变量的操作会添加内存屏障，禁止指令重排序

##### 简述 SortedSet 实现原理

* 继承关系，提供了元素排序功能，元素需实现Comparable接口
* 采用TreeSet实现，非线程安全，不会重复添加元素，采用TreeMap实现，红黑树存储和排序数据

##### 简述使用协程的优点

* 协程类似一种用户态的轻量级线程，线程I/O访问、时钟阻塞需要依赖内核态的调度，协程则具备调度自身的能力，非抢占式调度而是协作式调度
* 优点
  * 跨平台、跨体系架构
  * 高并发、高拓展、低成本
  * 减少反复系统调用、线程上下文切换的开销
  * 抢占式调度执行顺序无法确定，存在同步问题，协程的调度则不存在

##### Java 编译后的 .class 文件包含了什么内容？

* Java字节码类文件(.class)是一种8位字节的二进制流文件，每个类/接口都单独占据一个class文件，大致有以下数据项(u1/u2/u4/u8为字节长度)
  * 魔数(MagicNumber)，版本(Version)
  * 常量池，类访问权限，类索引，父类索引
  * 接口(interfaces)，成员(fields)，方法(methods)，属性(arributes)

##### 什么是公平锁？什么是非公平锁？

* 公平锁，线程按照申请锁顺序获取锁
  * 避免线程在队列中长期获取不到锁(线程饥饿)
* 非公平锁，新线程直接尝试获取锁，获取不到再进入阻塞队列
  * 减少整体CPU唤醒线程数量和开销(有些新线程直接运行)，整体吞吐量效率高

##### 如何判断一个 Hash 函数好不好？

见算法与数据结构中的HashMap部分



# 系统设计

简述 CAP 理论

简述 Kafka 的选举过程

常用的限流算法有哪些？简述令牌桶算法原理

什么是设计模式，描述几个常用的设计模式





# 中间件

##### 消息队列选型

常见消息队列特点和场景

* RabbitMQ，对消息队列功能和性能没有很高要求
* RocketMQ，处理在线业务，低延迟和高稳定性，如交易系统的订单
* Kafka，处理海量数据(大数据)，收集日志、监控信息、埋点数据等

![](./常见消息队列特点.png)

##### Redis数据淘汰策略

* 相关设置
  * maxmemory ，最大内存
  * maxmemory-policy，内存淘汰策略
  * maxmemory-samples，近似LRU随机采样数量
* 相关策略
  * noeviction，默认，拒绝写请求，返回错误
  * allkeys-lru/volatile-lru，从所有/设置过期时间的数据中淘汰最近最少使用
  * allkeys-random/volatile-random，从所有/设置过期时间的数据中随机淘汰
  * volatile-ttl，从设置过期时间的数据中淘汰最早过期的
  * (Redis 4.0) allkeys-lfu/volatile-lfu，从所有/设置过期时间的数据中淘汰最近访问频率低的

* 相关Tips

  * Redis采用近似LRU算法，随机选出5个key，淘汰其中最近最少使用

    Redis 3.0优化，维护16大小的候选池

    * 每次选取的数据访问时间小于池中最小时间(最近最少使用)会被访问池内
    * 池满后，新数据访问池，则将池内访问时间最大的移除
    * 淘汰时，选择池中最小时间的数据淘汰


