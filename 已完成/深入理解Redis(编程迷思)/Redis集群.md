# Redis集群

## 1.集群概述

### 概念

- 由多个主从节点组成
- 主节点负责读写请求和集群信息维护(哨兵)
- 从节点负责主节点数据和状态信息的复制

### 作用

- 数据分区

	- 数据分片到多个节点，突破单机内存限制
	- 每个主节点都可以提供读写服务，提高响应能力

- 高可用

	- 支持主从复制和自动故障转移
	- 任一节点故障时集群仍可提供服务

## 2.集群搭建

### 搭建6节点简单集群

- 3主节点，7000/7001/7002
- 3从节点，8000/8001/8002

### 搭建方式

- Redis命令，手动搭建

	- 集群模式启动节点

		- 关键配置

			- port 7000
cluster-enabled yes
cluster-config-file "node-7000.conf"

				- cluster-enabled，集群模式
				- cluster-config-file，节点维护的集群配置文件

		- 启动集群节点

			- 	redis-server redis-7000.conf

		- 查看节点状态

			- cluster nodes

				- 查看节点集群Id、集群中别的节点信息

	- 节点握手

		- 连接独立节点

			- cluster meet {ip} {port}

	- 分配数据槽

		- 集群共有16384个槽，是数据分区、管理、迁移的基本单位，所有槽分配了节点集群才可访问
		- 查看集群状态

			- cluster info

				- cluster_state:fail，集群处于下线状态

		- 分配槽

			- redis-cli -p 7000 cluster addslots {0..5461}
			- redis-cli -p 7001 cluster addslots {5462..10922}
			- redis-cli -p 7002 cluster addslots {10923..16383}

		- 查看集群状态

			- cluster info

				- cluster_state:ok，集群处于上线状态

	- 指定主从关系

		- 为从节点指定主节点
		- cluster replicate 集群节点Id

- Ruby脚本，自动搭建

	- 安装Ruby环境

		- apt-get install ruby

	- 安装ruby-redis依赖

		- gem install redis

	- 集群模式启动节点，同Redis命令相同
	- 搭建集群

		- {REDIS_HOME}/src/redis-trib.rb提供搭建集群命令
		- ./redis-trib.rb create 
--replicas 1 192.168.72.128:7000 192.168.72.128:7001 192.168.72.128:7002
192.168.72.128:8000 192.168.72.128:8001 192.168.72.128:8002

			- replicas指定每个主节点的从节点数量

		- 脚本打印创建集群计划，yes确认执行计划，集群搭建完毕

### 方案设计

- 高可用

	- 故障转移，至少3个主节点，且不在同一物理机
	- 每个主节点至少1个从节点，且不在同一物理机

- 节点数量

	- 主节点数量

		- 估算应用的总数据量和访问量 / 单节点的内存容量(benchmark估计)

	- 节点数量不足以满足应用需求

		- 大集群划分小集群
		- 减少不必要的数据
		- 调整数据过期策略

	- 适度冗余节点

		- 增加节点不影响集群服务

## 3.集群原理

### 数据分区

- 衡量数据分区标准

	- 数据分布均匀程度
	- 增删节点复杂度

- 顺序分区，数据分布不均匀
- 哈希分区

	- 哈希取余分区

		- key的hash值取余节点数量，计算数据存储节点
		- 增删节点，所有数据重新计算映射关系，引发数据迁移

	- 一致性哈希分区

		- 将全部哈希值(0-2^32-1)组成一个虚拟圆环
		- key的hash值在圆环上顺时针遇到的第一个节点即是数据存储节点
		- 增删节点

			- 复杂度低，只影响相邻节点的数据迁移
			- 节点数量较少，会引发数据分布不均

	- 虚拟节点的一致性哈希分区(Redis)

		- 数据和实际节点引入虚拟节点(槽)
		- 槽包含一定哈希范围内的数据，节点包含一定数量的槽
		- key的hash值->槽->实际节点
		- 增删节点，复杂度低，重新均匀分配槽给节点

### 通信机制

- 通信端口

	- 集群所有节点存在两个TCP端口
	- 普通端口

		- 配置指定，用于为客户端提供服务和数据迁移

	- 集群端口

		- 普通端口+10000(固定)
		- 用于节点间的通信

			- 搭建集群
			- 增减节点
			- 故障转移

- 通信协议

	- 单对单
	- 广播

		- 向集群所有节点发送消息
		- 优点，集群收敛快(所有节点收到信息一致)
		- 缺点，消息发给所有节点，CPU/带宽消耗大

	- Gossip

		- 每个节点与部分节点通信
		- 优点，负载低、去中心化、容错高
		- 缺点，集群收敛速度慢

- 消息类型

	- MEET消息(单对单)

		- 请求新节点加入当前集群
		- 节点握手，节点会向新加入的节点发送MEET消息
		- 新节点收到MEET消息会回复PONG消息

	- PING消息(Gossip)

		- 交换信息、心跳检测
		- 集群节点每秒会发送PING消息给部分节点

			- 随机选择5个节点中最久没有通信的一个
			- 扫描节点列表选择最近一次收到PONG消息大于cluster_node_timeout/2的所有节点

		- 收到消息的节点会回复PONG消息

	- PONG消息(单对单/广播)

		- 封装自身状态数据
		- 收到MEET/PING回复的PONG
		- 节点向集群广播的PONG

			- 故障恢复的新主节点

	- FAIL消息(广播)

		- 向集群传达下线判断
		- 主节点判断另一个主节点进入FAIL状态
		- 接收节点会保存此消息，用于后续判断

	- PUBLISH消息(广播)

		- 向集群传达命令
		- 节点收到PUBLISH命令会先执行命令，之后广播命令

### 数据结构

- 节点用于存储集群状态(上线/节点/主从/槽分布)
- clusterNode

	- 保存节点(自己/其他)状态
	- 主要字段

		- ctime，节点创建时间
		- name，节点ID
		- ip+port，节点IP和端口号
		- flags，节点标识(主从/是否在线/是否在握手)
		- configEpoch，配置纪元，用于故障转移
		- slots[16384/8]，槽在此节点的分布，16384比特，1-槽在节点中，0-槽不在节点中
		- numslots，节点的槽数量
		- 其他字段，节点连接、主从复制、故障发现转移等

- clusterState

	- 保存当前节点视角下的集群状态
	- 主要字段

		- myself，自身节点指针
		- currentEpoch，配置纪元
		- state，集群状态(上线/下线)
		- size，集群中至少包含一个槽的节点数量
		- nodes，哈希表，保存节点名称到clusterNode指针的映射
		- slots[16384]，槽分布的clusterNode指针数组
		- 其他字段，故障转移、槽迁移等

### 集群命令实现

- 节点握手命令(cluster meet)

	- 场景

		- 向集群节点A发送cluster meet命令与节点B握手

	- 流程(三次握手)

		- A为B创建clusterNode并将其添加到clusterSate的nodes字典中
		- A向B发送MEET消息
		- B收到MEET消息，为A创建clusterNode并加入clusterSate的nodes中
		- B向A回复PONG消息
		- A收到POING消息，A向B发送PING消息
		- B收到PING消息，握手完成
		- A通过Gossip协议将B信息广播给集群其他节点，其他节点与B握手

- 槽分配命令(cluster addslots)

	- 槽分配信息存储

		- clusterNode.slots，节点->槽，该节点持有哪些槽
		- clusterState.slots，槽->节点，所有的槽分别分配给哪个节点

	- 场景

		- 向集群节点A发送 cluster addslots {0..10}命令

	- 流程

		- 检查输入槽是否分配

			- clusterState.slots对应的值是否为NULL

		- 遍历输入槽，分配给节点A

			- 修改A节点的clusterNode.slots中对应比特为1
			- 修改clusterState.slots中对应指针指向A节点

		- A节点通过通信机制通知其他节点同步槽分配

## 4.客户端访问集群

### 客户端访问节点时数据可能不在该节点中

### Dummy客户端

- 执行命令前不知道数据处于哪个节点，如redis-cli
- 访问流程

	- 计算key->slot，CRC16(key) & 16383
	- 判断slot->node，查询clusterState.slot[i]

		- 槽属于当前节点，在当前节点执行查询命令
		- 槽在其他节点，将其ip/port包装到MOVED错误返回

	- 客户端收到MOVED错误后，根据返回的ip/port重新访问

### Smart客户端

- 执行命令前知道数据处于哪个节点，如JedisCluster

### 访问流程

- 初始化时连接集群节点维护slot->node映射
- 计算key->slot->node

	- 访问成功则命令执行完毕
	- 访问失败，出现MOVED，则重新同步slot->node映射

## 5.集群实践

### 集群伸缩

- 槽迁移(核心)

	- 修改槽与节点的对应关系

- 增加节点

	- 启动节点
	- 节点握手

		- redis-trib.rb add-node ip:port ip:port

	- 槽迁移

		- redis-trib,rb reshard ip:port(集群任意节点)，输入信息

			- 待迁移的槽数量
			- 目标节点的集群ID
			- 源节点(已分配槽)的集群ID

	- 指定主从关系

- 减少节点

	- 槽迁移

		- redis-trib,rb reshard ip:port

	- 下线节点

		- redis-trib.rb del-node ip:port(集群任意节点) delNodeId

			- 先下线从节点，再下线主节点

- 槽迁移时收到客户端访问，会返回ASK错误

### 故障转移

- 集群故障发现和转移与哨兵类似

	- 定时人物PING消息检测节点状态
	- 主观下线与客观下线
	- 选举领导者节点
	- 选举新主节点进行故障转移

- 关键概念

	- 主从节点故障

		- 集群和哨兵只实现主节点的故障转移，从节点故障只会下线

	- 集群节点数量

		- 故障转移选取新主节点需满足N/2+1，因此集群需要至少3个主节点

	- 集群故障转移时间

		- <= 1.5*cluster-node-timeout(15s) +1000，一般为20s量级

### Hash Tag

- 让不同的Key拥有相同的Hash值，从而分配到一个槽里
- 原理

	- {key}，不对整个key做hash，仅对{}包括的字符串做hash

- 优点

	- 可在集群中，针对不同key进行批量操作(mget/mset)
	- 支持集群事务及Lua脚本(所涉及key在同一节点)

- 缺点

	- 数据分配不均

		- 调整不同节点槽数量
		- 避免对热点数据运用Hash Tag

### 参数优化

- cluster_node_timeout(15s)

	- 影响PING消息传播接节点范围

		- 值越大，延迟容忍度高，传播节点少

			- 降低集群消息收敛速度
			- 降低带宽等资源消耗

	- 影响故障转移判定

		- 值越大，延迟容忍度高

			- 完成故障转移消耗时间长
			- 不容易误判

- cluster-require-full-coverage(yes)

	- 集群是否槽完全分配才可上线

### redis-trib.rb脚本

- 提供许多实用工具

	- 创建集群
	- 增减节点
	- 槽迁移
	- 检查完整性
	- 重新平衡数据

- 集群尽量使用，降低出错概率

*XMind - Trial Version*